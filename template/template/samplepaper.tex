\documentclass[runningheads]{llncs}

\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage[export]{adjustbox}
\usepackage[noend]{algpseudocode}

\usepackage{epstopdf} %converting to PDF

\setcounter{secnumdepth}{3}

\begin{document}

% \thanks{Supported by organization x.}
\title{Parallel Genetic Algorithm for Regression}

\author{Paulo Santos \and
Maria Fidalgo
}
%\authorrunning{F. Author et al.}

\institute{Departamento de Informática da Faculdade de Ciências da Universidade de Lisboa
\email{\{fc47806,fc49034\}@alunos.fc.ul.pt}}

\maketitle

\begin{abstract}
The first sentence of an abstract should clearly introduce the topic of the paper so that readers can relate it to other work they are familiar with. However, an analysis of abstracts across a range of fields show that few follow this advice, nor do they take the opportunity to summarize previous work in their second sentence. A central issue is the lack of structure in standard advice on abstract writing, so most authors don’t realize the third sentence should point out the deficiencies of this existing research. To solve this problem, we describe a technique that structures the entire abstract around a set of six sentences, each of which has a specific role, so that by the end of the first four sentences you have introduced the idea fully. This structure then allows you to use the fifth sentence to elaborate a little on the research, explain how it works, and talk about the various ways that you have applied it, for example to teach generations of new graduate students how to write clearly. This technique is helpful because it clarifies your thinking and leads to a final sentence that summarizes why your research matters.

\keywords{Parallel Genetic Programming \and Regression \and Island Model.}
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Genetic Algorithms (GAs) are metaheuristic searching algorithms where the main idea lies in following the same principles as Natural Selection and Evolution in Biology \cite{sivanandam2008genetic}. That is, the algorithms work around a \textit{population} of potential solutions for the problem, the \textit{individuals}. The population changes during the execution of the algorithm, mimicking the evolution of a real population of living beings, from generation to generation, where the fitter individuals are more likely to survive and reproduce.

The algorithm is composed by three main operations: Fitness, Crossover, Mutation and Selection. Fitness measures how good an individual is; Crossover (or sexual reproduction) generates a new solution based on two existing ones, simulating the breeding of two individuals; and Mutation (or asexual reproduction) produces random changes to an individual; Selection determines how the individuals are chosen for the Crossover and Mutation \cite{langdon1995genetic}.

Due to the characteristics of the GAs, applications are often related to optimization \cite{sivanandam2008genetic}, such as the Traveling Salesman Problem \cite{grefenstette1985genetic}, classification \cite{5340522}, decision making \cite{George:2012:GAB:2345396.2345426} and prediction \cite{etemadi2009genetic}.

Prediction can be accomplished through Regression Analysis, which is the task of modeling a random variable $Y$ as a function of a vector of random variables $X$. This may be translated as the task of finding the mathematical expression best suited to explain $Y$. Regression models presuppose the existence of constants, called \textit{parameters}, that are to be estimated from the data \cite{rawlings2001applied}.

However, when using a GA for this type of problem, it is not the parameters that we want to estimate but the whole mathematical expression. Therefore, we will be looking for the one that minimizes the error between the value provided by the model and the actual value.

In this work, we explore different parallelizations of the Genetic Algorithm for regression, using the toxicity dataset \cite{krawiec2013genetic}. We will start by introducing the algorithm and its operations in further detail. Next, we will present the several approaches studied:

\begin{itemize}
\item Sequential
\item Adaptive Sequential
\item Trivial Parallelization
\item Island Parallelization
\end{itemize}

Finally, we will demonstrate the experimental evaluation and compare with each other.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Genetic Algorithm}

The implementation of a GA typically starts with a population of random individuals. Then, the population is evaluated, and reproduction operations take place \cite{whitley1994genetic}. Bellow, we present the pseudo-code for the genetic algorithm. The $AddElitesToNewPopulation$ is an optional but often used step, where a designated percentage of the best individuals are directly transfered to the new population (without any modification). This helps the algorithm to converge faster and prevents it from losing the best solutions \cite{martins2016gacuda}.

\begin{algorithmic}
   \State \textbf{Input}:$Max_{gen},Pop_{size},P_{cross},P_{mut},P_{reproduction}$
   \State \textbf{Output}:$S_{best}$
   \State $Population\gets InitializePopulation(Pop_{size},nodes_{func},nodes_{term})$
   \State $MeasureFitness(Population)$ \Comment{Evaluation of the population}
   \State $S_{best} \gets GetBestSolution(Population)$
   \State $Generation_{i} \gets 0$
   
   \While{$Generation_{i} \not= Max_{gen}$}
      \State $Generation_{i} \gets Generation_{i} + 1$
      \State $NewPopulation \gets \emptyset$
      \State $AddElitesToNewPopulation(Population,NewPopulation)$ \Comment{Optional step}
   
      \While{$Size(NewPopulation) < Pop_{size}$}
         \State $Ind_{1}, Ind_{2} \gets SelectForCrossover(Population, P_{reproduction})$
         \State $NewGeneration \gets NewGeneration \cup Mutate(Crossover(Ind_{1},Ind_{2},P_{cross}),P_{mut})$
         \State $MeasureFitness(NewPopulation)$
      \EndWhile
      
      \State $S_{best} \gets GetBestSolution(NewPopulation)$
      \State $Population \gets NewPopulation$
   \EndWhile
   \State \textbf{return} $S_{best}$
\end{algorithmic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach}

\subsection{Encoding}

%% types of encoding

Originally, binary encoding was used to encode the solution \cite{whitley1994genetic}. That is, an individual was represented by a vector where each entrance corresponded to some feature being true for that particular individual. Later, other types of encoding were propposed in order to represent more sophisticated types of individuals, like the value encoding, permutation encoding, and trees \cite{martins2016gacuda}. We chose the last one for our work, since our goal is to encode expressions, that can be directly mapped to Abstract Syntax Trees.

Choosing an Abstract Syntax Tree for the encoding allows us to easily generate random mathematical expressions with an immutable tree. Each node of the tree either represents a binary operator ($+,-,*,whole division$) node or a constant node, which can be a variable or value (any integer from -1000 to 1000).

The variable names were generated according to the dataset: from $x_{1}$ to $x_{n}$, where $n$ is the number of features from the dataset.

\subsection{Fitness}

\subsection{Selection}

\subsection{Crossover}

Since each tree represents an individual, it has a crossover operation which allows it to generate offspring by crossing itself with another tree in a single-point of crossing. This has been accomplished by randomly choosing and swapping two nodes from each tree.

\subsection{Mutation}

Every tree may also mutate itself by randomly choosing one node and changing its inner value. A constant binary node could have its inner content changed with a new value or variable, while binary operator nodes would have their operation changed.

\subsection{Parallelization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation Details}

\subsection{Abstract Syntax Tree}

As mentioned above, Abstract Syntax Trees allow us to generate random mathematical expressions. Moreover, by using a Java expression builder\footnote{\href{https://www.objecthunter.net/exp4j/index.htm}{exp4j - Expression Builder from String for Java}}, it was possible to easily map values to variables of a given expression and obtain the result from it, which is useful when calculating the fitness of the tree.
%
%\subsection{Sequential Genetic Algorithm}
%The sequential implementation of a regular genetic algorithm where each genetic algorithm operation has fixed ratios. 
%
%The fitness is measured using linear regression \textbf{TODO:} %%%%%%%%%%%%%%%%% MARIA !!! Eu nao sei esta parte do measure fitness com regressao linear
%
%The population is sorted from best fitness to worst fitness using a default arrays sorting algorithm from Java in order to obtain the best individual at a certain generation. This individual remains unchanged to the next generation, and the rest of the population is replaced with generated offspring by crossing parents using a Fitness Proportionate Selection, where the best individuals have a higher chance of being chosen for crossover.
%
%Each offspring contains 10\% chance of being selected to suffer a mutation.

\subsection{Adaptive Genetic Algorithm}
The Adaptive implementation of a GA diverges from the regular implementation by not having the mutation and crossover rates fixed. Instead, the mutation and crossover rates are dynamic, and adapt depending on the progression made by each operation in the last generation \cite{adaptativeCrossOverMutation}.

The new offsprings are generated by crossing parents using an Adapted Fitness Proportionate Selection. Since new offsprings are always generated by crossing two individuals, the crossover rate will influence the probability each individual has of being chosen. This has been attained by using the absolute value of the normal probability density function, and multiplying it by the sum of a third of the amount of population with the crossover rate. The crossover rate is an integer value between \(-populationSize\) and \(populationSize\).

\[ \left |\left | \frac{1}{\sigma \sqrt{2\pi}}*e^{-\frac{(-\mu)^2}{2\sigma^2}} \right | * (popSize\,/\,3) + crossoverRate)  \right | \%  \, popSize \]	

The mutation rate controls the probability of an individual to suffer a mutation. This value is a value between 0.05 and 1.0.

Both rates are updated according to the progressions they obtained for each individual. The chosen mutation rate offset is 0.05 and the crossover rate offset is \(populationSize * 0.025\).

\begin{algorithmic}
\If {$mutationProgress < crossOverProgress$}
        \State $mutationRate := min(1.0, mutationRate + mutationOffset)$
        \State $crossoverRate := max(-popSize, crossoverRate - mutationOffset)$
\EndIf
\If {$mutationProgress > crossOverProgress$}
        \State $mutationRate := max(mutationOffset, mutationRate - mutationOffset)$
        \State $crossoverRate := min(popSize, crossoverRate + mutationOffset)$
\EndIf
\end{algorithmic}

\subsection{Parallel Versions Implementation}
\subsubsection{Parallel Population Sorting} \label{subsubsec:parallelSort} \hfill \par
Due to parallel mergesort ease of implementation and advantages of execution time \cite{analysisMergeSort}, the sorting of the population by fitness has been implemented with a parallel mergesort with linear insertion sort when the amount of population to compute is smaller than an offset of 7. The population is splitten by half until the offset is reached and the insertion sort and merge algorithms' are computed.


\subsubsection{ForkJoin} \hfill \par
\textbf{TODO:}

\subsubsection{Phaser} \hfill \par
The Phaser approach uses phasers in order to introduce a synchronization point between all the threads running.

First of, there has been made the decision of creating \(N\) threads proportional to the amount of available processors of the machine. A smaller value would not take advantage of all the processing power available, whereas a higher value would have a negative impact on the performance, since the CPU scheduler would give each one of those \(N > availableProcessors\) some share of CPU time.

Every thread is responsible for a portion of the population. In order to maintain consistency in the population over the several generations, and between different threads, it is required a synchronization point, the phaser. 

The synchronization point has been introduced before and after the transition from the old population to the new one. This is a requirement since the GA operations cannot happen until every single expression from the new population has been introduced in the current population.

Additionally, it was also introduced synchronization points before and after sorting the population. After every single individual has transitioned from the old to the new population, the thread with \(threadId := 0\) launches the \hyperref[subsubsec:parallelSort]{Parallel Population Sorting} algorithm. Once the algorithm finishes, every thread gets through the synchronization point and a new generation starts.

The phaser runs the regular GA approach to compute each individual.

\subsubsection{Island} \hfill \par
In order to take advantage of the amount of available processors we have also implemented an Island Model for the GA\cite{islandModelGA}.

In our approach we took into account the quantity of available processors to create and hold the computation of the islands. Each island has its own portion of the population, with size  \(populationSize / amountIslands \), and is independent of the other islands. Consequently, synchronization points are not required. Occasionally - every 20 generations - the best individual of an island is sent to a random island and waits in a \emph{ConcurrentLinkedQueue} until the sort starts, when the last (worst) individual is replaced with the new one.

A naive approach would be to create one island per available processor. Our implementation allows us to create a variable amount of islands between $1$ and the amount of available processors.

 If the specified amount of islands is smaller than the amount of processors then the remaining available processors will be evenly distributed through the islands, allowing these to contain inner parallelization. The inner parallelization allows the island to split the population with the amount of threads it has been assigned and compute each generation quicker. As in the Phaser approach, phasers were also used here to create synchronization in the points mentioned earlier. In this case the island is responsible for calling the \hyperref[subsubsec:parallelSort]{Parallel Population Sorting} algorithm.

When an island completes its computation, it redistributes the upcoming available threads with the rest of the islands starting by the end. This way we are able to reuse the processors once they're free. The redistribution is implemented using a \(ConcurrentLinkedQueue<Pair<Integer, Integer>>\), where the island sends a message to create a new thread to another active island containing \(<islandId, \,newAmountThreads>\).

Every island runs the regular GA approach to compute each individual.

\begin{figure}[htbp]
\centering
\includegraphics[width=.92\textwidth]{IslandModel.png}
\caption{Example of thread redistribution after island 1 has terminated and island 4 and island 5 create one new thread each. Settings: 8 processors, 5 islands.} \label{islandDiagram}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}

\subsection{Experimental Setup}
The tests were made on a 24 cores machine with Intel(R) Xeon(R) CPU X5670@2.93GHz processors.

The results have been gathered by running each approach previously presented 30 times, with a population of 1.000 for 500 generations. An individual, expression tree, was able to achieve \(2^{10} + 1\) nodes when created and up to \(2^{15} + 1\) nodes after crossing with another individual. For first 250 generations the data set has been split in half and each part was tested intercalated.

\subsection{Results}

+ Comparacao dos resultados da regular linear com a adaptative linear

\begin{figure}[htbp]
\centering
\adjincludegraphics[width=\textwidth, trim={100 110 25 20}, clip]{ComparacaoIlhas}
\caption{Comparison of the performance of sequential and parallel versions of the algorithm.} \label{fig1}
\end{figure}
+ Comparacao dos resultados da de ilhas com 6 ilhas, 12 ilhas, 18 ilhas e 24 ilhas

\begin{figure}[htbp]
\centering
\adjincludegraphics[width=\textwidth, trim={90 110 15 20}, clip]{ComparisonWithLinear}
\caption{Comparison of the performance of sequential and parallel versions of the algorithm.} \label{fig1}
\end{figure}
+ Comparacao de todas as implementacoes em termos finais de execucao com boxplot

\begin{figure}[htbp]
\centering
\adjincludegraphics[width=\textwidth, trim={90 110 25 20}, clip]{ComparisonNoLinear}
\caption{Comparison of the performance of sequential and parallel versions of the algorithm.} \label{fig1}
\end{figure}

In this section you should present the results. Do not forget to explain where the data came from. 

You should include (ideally vectorial) plots, with a descriptive caption. Make sure all the plots (Like Figure~\ref{fig1} are well identified and axis and metrics are defined.

\subsection{Discussion}

Here you should discuss the results on a high level. For instance, based on our results, the parallelization of the merge-sort is relevant as no other parallel work occurs at the same time, and the complexity $O(N log(N))$ can have a large impact when the number of individuals is high.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}

Several implementations of the genetic algorithm were made throughout the years. We will shortly talk about two implementations and how they fit in the scope of our work.

Dominic and Willis  \cite{GPTIPS} developed a MATLAB toolbox, GPTIPS, which is able to perform regression through genetic programming. The main difference between their approach and  ours is that they do not explore the parallelism of the algorithm, focusing on the usability of the toolbox. Moreover, they chose to include nonlinear operators, that we decided to leave out. Our work is, therefore, important to whom intends to develop a fast approach of the genetic classifier. Additionally, GPTIPS requires the purchase of a payed software (MATLAB), available to a less broader population.

Jenetics \cite{jenetics} is another genetic programming implementation. It is a Java library designed to abstract different concepts within the genetic programming panorama, such as Gene, Genotype and Chromosome, allowing it to serve a vast spectrum of domains. This library implements the Java Stream Interface and provides ForkJoin Parallelization. This is, therefore, a generic purpose implementation for genetic algorithm. On the other hand, in our work we provided a study of genetic programming specific for regression, where other parallelization techniques were able to achieve better results than ForkJoin, like the Island Models.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}

Here you should resume the major conclusions taken from discussion. Ideally, these should align with the objectives introduced in the introduction.


You should also list the future work, i. e., tasks and challenges that were outside your scope, but are relevant.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

First Author wrote the part of the program implemented the phasers. Second Author implemented the MergeSort in parallel. 

Both authors wrote this paper, with First Author focusing on the introduction, related work and conclusions while the Second Author focused on approach and evaluation.

Each author spent around 30 hours on this project.

\bibliographystyle{splncs04}
\bibliography{bibliography}

\end{document}
